package com.bookingservice.service.impl;

import com.bookingservice.client.FlightClient;
import com.bookingservice.model.Booking;
import com.bookingservice.repository.BookingRepository;
import com.bookingservice.request.BookingRequest;
import com.bookingservice.service.BookingService;
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;

import java.time.LocalDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class BookingServiceImpl implements BookingService {

    private final BookingRepository repo;
    private final FlightClient flightClient;

    /**
     * ====================== BOOK FLIGHT ======================
     * Returns 201 Created if success
     * Returns 400/500 based on seat availability or fallback
     */
    @Override
    @CircuitBreaker(name = "bookingCB", fallbackMethod = "bookingFallback")
    public Mono<Booking> bookFlight(BookingRequest req) {

        Mono<Boolean> onward = flightClient.reserveSeats(
                req.getFlightIdOnward(), req.getSeatNumbersOnward().size()
        );

        Mono<Boolean> returning = req.getTripType().equalsIgnoreCase("ROUND_TRIP") ?
                flightClient.reserveSeats(req.getFlightIdReturn(), req.getSeatNumbersReturn().size()) :
                Mono.just(true);

        return Mono.zip(onward, returning)
                .flatMap(t -> {
                    boolean ok1 = t.getT1();
                    boolean ok2 = t.getT2();

                    if (!ok1 || !ok2)
                        return Mono.error(new RuntimeException("No seats available — Booking Failed"));

                    Booking booking = Booking.builder()
                            .pnr(UUID.randomUUID().toString().substring(0, 8).toUpperCase())
                            .tripType(req.getTripType())
                            .flightIdOnward(req.getFlightIdOnward())
                            .flightIdReturn(req.getTripType().equalsIgnoreCase("ROUND_TRIP") ?
                                    req.getFlightIdReturn() : null)
                            .seatNumbersOnward(req.getSeatNumbersOnward())
                            .seatNumbersReturn(req.getTripType().equalsIgnoreCase("ROUND_TRIP") ?
                                    req.getSeatNumbersReturn() : null)
                            .userName(req.getUserName())
                            .email(req.getEmail())
                            .passengers(req.getPassengers())
                            .meal(req.isMeal())
                            .journeyDate(req.getJourneyDate())
                            .returnDate(req.getTripType().equalsIgnoreCase("ROUND_TRIP") ?
                                    req.getReturnDate() : null)
                            .bookingDateTime(LocalDateTime.now())
                            .status("BOOKED")
                            .build();

                    return repo.save(booking);
                })
                .map(saved -> {
                    // ★ Set HTTP Response Code = 201 Created
                    org.springframework.http.server.reactive.ServerHttpResponse response =
                            org.springframework.web.server.ServerWebExchangeContextFilter.getCurrent().getResponse();
                    response.setStatusCode(HttpStatus.CREATED);
                    return saved;
                });
    }

    // Fallback when FLIGHT SERVICE is down
    private Mono<Booking> bookingFallback(BookingRequest req, Throwable ex) {
        return Mono.error(new RuntimeException("❗ Flight-Service DOWN — Try booking later"));
    }


    /**
     * ====================== GET BY PNR ======================
     * Returns 200 if exists
     * Returns 404 if not found
     */
    @Override
    public Mono<Booking> getByPnr(String pnr) {
        return repo.findByPnr(pnr)
                .switchIfEmpty(Mono.error(new RuntimeException("❗ Booking Not Found — PNR Invalid")));
    }


    /**
     * ====================== HISTORY BY EMAIL ======================
     */
    @Override
    public Flux<Booking> getHistoryByEmail(String email) {
        return repo.findByEmail(email);
    }


    /**
     * ====================== CANCEL BOOKING ======================
     * Returns 200 OK on success
     * Returns 404 if invalid PNR
     * Prevent cancellation if < 24 hours to journey
     */
    @Override
    @CircuitBreaker(name = "cancelCB", fallbackMethod = "cancelFallback")
    public Mono<String> cancel(String pnr) {
        return repo.findByPnr(pnr)
                .switchIfEmpty(Mono.error(new RuntimeException("❗ Invalid PNR — No Booking Found")))
                .flatMap(b -> {

                    // ❗ Block cancellation if journey is < 24 Hrs ahead
                    LocalDateTime now = LocalDateTime.now();
                    LocalDateTime journey = b.getJourneyDate().atStartOfDay();

                    if (!now.isBefore(journey.minusHours(24)))
                        return Mono.error(new RuntimeException("❗ Cancellation Allowed ONLY before 24 hours"));

                    // Release onward seats
                    Mono<Boolean> onward = flightClient.releaseSeats(
                            b.getFlightIdOnward(), b.getSeatNumbersOnward().size()
                    );

                    // Return seats if ROUND TRIP
                    Mono<Boolean> returning = b.getTripType().equalsIgnoreCase("ROUND_TRIP")
                            ? flightClient.releaseSeats(b.getFlightIdReturn(), b.getSeatNumbersReturn().size())
                            : Mono.just(true);

                    return Mono.zip(onward, returning)
                            .then(repo.delete(b).thenReturn("✓ Ticket Cancelled Successfully"));
                });
    }

    private Mono<String> cancelFallback(String pnr, Throwable ex) {
        return Mono.just("❗ Flight-Service DOWN — Cancellation not possible");
    }
}
